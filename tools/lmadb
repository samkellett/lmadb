#!/usr/bin/env python

import argparse
import atexit
import platform
import pylmadb
import os
import shutil
import tempfile

from prompt_toolkit import prompt
from prompt_toolkit.history import InMemoryHistory

def handle_meta_command(conn, command, args):
    if command == 'tables':
        for table in conn.list_tables():
            print(table)
    elif command == 'schema':
        if len(args) != 1:
            #Â TODO: make this a UsageError
            raise RuntimeError('wrong arguments.')

        for column, ty in conn.describe_table(args[0]):
            print(column, ty)
    else:
        raise RuntimeError('unknown meta command .{}'.format(command))

parser = argparse.ArgumentParser(description='LMADB command line client.')
parser.add_argument('path', type=str, nargs='?', help='path to database')

args = parser.parse_args()

print('LMADB version {}, Python version {}'.format(pylmadb.__version__, platform.python_version()))

if args.path is None:
    # create a temporary database that is destroyed on exit.
    tmpdir = tempfile.mkdtemp()
    atexit.register(lambda: shutil.rmtree(tmpdir))

    args.path = os.path.join(tmpdir, 'lmadb')
    print('Connected to a transient database: {}'.format(args.path))

conn = pylmadb.connection(args.path)
history = InMemoryHistory()

while True:
    command = prompt('> ', history=history)
    if len(command) == 0:
        continue

    if command == 'quit' or command == 'q':
        break

    try:
        if command.startswith('.'):
            args = command.split(' ')
            handle_meta_command(conn, command=args[0][1:], args=args[1:])
        else:
            stmt = conn.prepare(command)
            for row in stmt:
                print(row)
    # TODO: this should be our own error type.
    except RuntimeError as e:
        print('Error: {}'.format(e))
